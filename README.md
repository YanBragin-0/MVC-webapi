 ASP.NET Core MVC + Entity Framework Core + PostgreSQL
1. Создаём проект в Visual Studio с шаблоном asp net core Модель-представление-контроллер.
2. Устанавливаем пакеты NuGet:
                              MicrosoftEntityFrameworkCore   "(ORM)"
                              NpgSql.EntityFrameworkCore.PostgreSQL
                              // по желанию для тестов - Swashbuckle.aspnetcore(Безлимитный swagger)
                              //Dependency Injection - уже есть в asp net core       
4. Модель: Сущности, Репозитории,Сервисы (их абстракции для Dependency Injection). Вся логика приложения (и его бизнес логика).
   Алгоритм выполнения (запрос в контроллер -> в сервис -> в репозиторий из него в DbContext) Когда контроллер уже получит данные отдаем -> View  (Паттерн Clean Architecture)
5. Контроллер - (слушает запрос и перенаправляет в сервис и так далее по цепочке)
6. Представление (View) - вызовется то которое в данный момент вызвал какой либо контроллер. В asp net core ((Razor Page, Blazor) - .cshtml).
                                                            Лучше не использовать вообще, frontend должен быть на javscript(angular,react,...)
Представление и есть наш файл шаблона(в нашем случаем Razor Page)
7. Фабрика по сути может быть отдельным DbContext для создания миграций без Dependency Injection (У нас ApplicationDbContext с этим справляется и при этом хранит DbSet и настройки сущностей(связи и правила)).
   В Program.cs берется строка подключения из appsettings.json.
   В терминале выполняем _dotnet ef migrations add <Название миграции>_ -> добавится папка Migrations (в ней будут "правила" для их применения к БД (по сути указание EF Core, какие создать таблицы и как)).
                                                ORM(EF Core) сам отследит какие сущности являются ключевыми для заполнения БД, правила прописываем в _protected override OnModelCreating_ в ApplicationDbContext
   После, выполняем _dotnet ef database update_ ибо до этого миграции только созданы но не применены.
   Получим заполненую БД.
8. Сидер - не был использован в проекте (Опционально можно добавить в проект Класс Сидер который будет при старте приложения заполнять какими-то начальными данными нашу БД).
                                                                                          В нашем случае при многократном запуске не очень желательно, для того что бы не дублировались данные
                                                                                             (хотя можно прописать проверку на присутствие таких данных в БД но это уже лишняя накладка на производительность).
                                                                                           _"В общем заполняем данные по нормальному через методы"_
   
9.Маршрутизация - В проекте реализована через атрибуты контроллеров(которые вызовут потом соответствующие View)
                                              (смотреть _Controllers/[**...**] public async Task..._ там маршрут(подход web API), хоя можно настраивать явно в Program.cs(MapControllers)) 

                                              
Есть несколько тестовых контроллеров "BirdsController" и тестовые Views для проверки работоспособности                                                   
